@page "/read/{sourceLang}/{targetLang}/{textId}"
@implements IDisposable
@using POT_SEM.Core.Models
@using POT_SEM.Services.Builders
@using POT_SEM.Services.Processing
@inject TextProviderBuilder Builder
@inject TextProcessingFacade Facade
@inject NavigationManager Navigation

<PageTitle>üìñ Reading: @(_originalText?.Title ?? "Loading...")</PageTitle>

<div class="reading-container">
    <!-- Header -->
    <div class="reading-header">
        <button @onclick="GoBack" class="btn-back">‚Üê Back to Texts</button>
        
        @if (_originalText != null)
        {
                    <div class="text-info">
                <h1>@_originalText.Title</h1>
                <div class="meta">
                    <span class="badge">@SourceLang ‚Üí @TargetLang</span>
                    <span class="badge difficulty-@_originalText.Difficulty.ToString().ToLower()">
                        @_originalText.Difficulty
                    </span>
                    <button class="btn btn-sm btn-outline-secondary ms-2" @onclick="ToggleSentenceTranslations">
                        @(showSentenceTranslations ? "Hide" : "Show") + " sentence translations"
                    </button>
                    <button class="btn btn-sm btn-outline-secondary ms-2" @onclick="ToggleTransliteration">
                        @(showTransliteration ? "Hide" : "Show") + " transliteration"
                    </button>
                    @if (_originalText.Metadata?.EstimatedReadingTimeMinutes > 0)
                    {
                        <span class="badge">~@_originalText.Metadata.EstimatedReadingTimeMinutes min</span>
                    }
                </div>
            </div>
        }
    </div>
    
    <!-- Error State -->
    @if (_errorMessage != null)
    {
        <div class="alert alert-danger">
            <strong>‚ùå Error:</strong> @_errorMessage
            <br/>
            <button @onclick="LoadText" class="btn-retry">üîÑ Retry</button>
        </div>
    }
    
    <!-- Reading Content -->
    @if (_processedText != null)
    {
        <div class="reading-content">
            <div class="stats">
                üìä Stats: 
                <strong>@_processedText.TotalSentences</strong> sentences, 
                <strong>@_processedText.TotalWords</strong> words, 
                <strong>@_processedText.UniqueWords</strong> unique
            </div>
            
            <!-- Sentences -->
            @foreach (var sentence in _processedText.Sentences)
            {
                <div class="sentence" id="sentence-@sentence.Index">
                    <div class="sentence-number">@(sentence.Index + 1)
                        <button class="btn btn-sm btn-link sentence-translate-btn" title="Translate sentence" @onclick="() => TranslateSentenceNow(sentence)" disabled="@IsSentenceLoading(sentence.Index)">
                            <svg class="icon-translate" width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#5d6d7e" d="M12 2v2a8 8 0 1 1-8 8H2a10 10 0 1 0 10-10V2z"></path></svg>
                        </button>
                        @if (sentenceStatus.TryGetValue(sentence.Index, out var st) && !string.IsNullOrEmpty(st))
                        {
                            <svg class="status-icon @GetStatusClass(st)" title="@st" viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><circle cx="5" cy="5" r="5"/></svg>
                        }
                    </div>
                    <div class="sentence-content">
                        <!-- Original text with interactive words -->
                        <div class="sentence-text" dir="@GetTextDirection(SourceLang)">
                            @foreach (var word in sentence.Words)
                            {
                                if (word.IsPunctuation)
                                {
                                    <span class="punctuation">@word.Original</span>
                                }
                                else
                                {
                                    var hasFuri = !string.IsNullOrEmpty(word.Furigana) || (word.Metadata.ContainsKey("hasFurigana") && word.Metadata["hasFurigana"] is bool b && b);

                                    if (SourceLang == "ja" && hasFuri)
                                    {
                                            <span class="word-wrapper" tabIndex="0" role="button" aria-label="@GetTooltip(word)" data-transliteration="@word.Transliteration">
                                                <ruby>
                                                    <span>@word.Original</span>
                                                    <rt>@(word.Furigana ?? "")</rt>
                                                </ruby>
                                                        <span class="word-translation">
                                                            @if (word.DictionaryEntry?.Meanings?.Count > 0)
                                                            {
                                                                @string.Join("; ", word.DictionaryEntry.Meanings)
                                                            }
                                                            else if (!string.IsNullOrEmpty(word.Translation))
                                                            {
                                                                @word.Translation
                                                            }
                                                        </span>
                                                @if (showTransliteration && !string.IsNullOrEmpty(word.Transliteration))
                                                {
                                                    <div class="word-transliteration">@word.Transliteration</div>
                                                }
                                            </span>
                                    }
                                        else
                                        {
                                            var pendingAttr = (word.Metadata.ContainsKey("hasFurigana") && word.Metadata["hasFurigana"] is bool has && has == false) ? "false" : "true";
                                            <span class="word-wrapper" tabIndex="0" role="button" aria-label="@GetTooltip(word)" data-has-furigana="@pendingAttr" data-transliteration="@word.Transliteration">
                                                <span class="word-original">@word.Original</span>
                                                @if (word.DictionaryEntry?.Meanings?.Count > 0 || !string.IsNullOrEmpty(word.Translation))
                                                {
                                                    <span class="word-translation">
                                                        @if (word.DictionaryEntry?.Meanings?.Count > 0)
                                                        {
                                                            @string.Join("; ", word.DictionaryEntry.Meanings)
                                                        }
                                                        else if (!string.IsNullOrEmpty(word.Translation))
                                                        {
                                                            @word.Translation
                                                        }
                                                    </span>
                                                }
                                                
                                                @if (showTransliteration && !string.IsNullOrEmpty(word.Transliteration))
                                                {
                                                    <div class="word-transliteration">@word.Transliteration</div>
                                                }
                                            </span>
                                        }
                                }
                            }
                        </div>
                        
                        <!-- Sentence translation -->
                            @if (showSentenceTranslations && !string.IsNullOrEmpty(sentence.Translation))
                            {
                                <div class="sentence-translation">
                                    üí¨ @sentence.Translation
                                </div>
                            }
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {
    [Parameter] public string SourceLang { get; set; } = "en";
    [Parameter] public string TargetLang { get; set; } = "sk";
    [Parameter] public string TextId { get; set; } = "";
    
    private string? _errorMessage = null;
    private Text? _originalText;
    private ProcessedText? _processedText;
    
    private HashSet<int> _loadingSentences = new();

    private bool IsSentenceLoading(int idx) => _loadingSentences.Contains(idx);

    private async Task TranslateSentenceNow(ProcessedSentence sentence)
    {
        if (sentence == null) return;
        _loadingSentences.Add(sentence.Index);
        StateHasChanged();

        try
        {
            var translated = await Facade.ProcessSentenceAsync(sentence.OriginalText, SourceLang, TargetLang);
            if (translated != null && !string.IsNullOrEmpty(translated.Translation))
            {
                sentence.Translation = translated.Translation;
                sentenceStatus[sentence.Index] = "ok";
                _ = Task.Run(async () => { await Task.Delay(3000); sentenceStatus.Remove(sentence.Index); StateHasChanged(); });
            }
            else
            {
                sentenceStatus[sentence.Index] = "empty";
                _ = Task.Run(async () => { await Task.Delay(3000); sentenceStatus.Remove(sentence.Index); StateHasChanged(); });
            }
        }
        catch (Exception ex)
        {
            sentenceStatus[sentence.Index] = "fail";
            Console.WriteLine($"‚ùå TranslateSentenceNow failed: {ex.Message}");
            _ = Task.Run(async () => { await Task.Delay(3000); sentenceStatus.Remove(sentence.Index); StateHasChanged(); });
        }
        finally
        {
            _loadingSentences.Remove(sentence.Index);
            StateHasChanged();
        }
    }

    private Dictionary<int, string> sentenceStatus = new();
    private string GetStatusClass(string status)
    {
        return status switch
        {
            "ok" => "status-ok",
            "fail" => "status-fail",
            "empty" => "status-empty",
            _ => "status-empty"
        };
    }
    protected override async Task OnInitializedAsync()
    {
        await LoadText();
    }

    private bool showSentenceTranslations = false;
    private bool showTransliteration = false;

    private void ToggleTransliteration()
    {
        showTransliteration = !showTransliteration;
    }

    private void ToggleSentenceTranslations()
    {
        showSentenceTranslations = !showSentenceTranslations;
    }
    
    private async Task LoadText()
    {
        _errorMessage = null;
        
        try
        {
            Console.WriteLine($"üìñ Loading text: {TextId} ({SourceLang} ‚Üí {TargetLang})");
            
            // STEP 1: Load original text by TextId (attempt to fetch a batch and find the requested id)
            var difficulty = ParseDifficulty(TextId);
            var provider = Builder.ForLanguage(SourceLang).ForDifficulty(difficulty).Build();

            // Try fetching a larger batch and match by Id or Title
            var texts = await provider.GetTextsAsync(topic: null, count: 20);
            _originalText = texts.FirstOrDefault(t => string.Equals(t.Id, TextId, StringComparison.OrdinalIgnoreCase));

            if (_originalText == null)
            {
                _originalText = texts.FirstOrDefault(t => !string.IsNullOrEmpty(t.Title) && t.Title.Contains(TextId, StringComparison.OrdinalIgnoreCase));
            }

            if (_originalText == null)
            {
                throw new Exception("Text not found");
            }
            
            Console.WriteLine($"‚úÖ Loaded text: '{_originalText.Title}'");
            
            // STEP 2: Create initial processed text with just the original content (no translations yet)
            // Parse sentences immediately to show structure
            var sentenceTexts = _originalText.Content.Split(new[] { '.', '!', '?', '„ÄÇ', 'ÔºÅ', 'Ôºü' }, StringSplitOptions.RemoveEmptyEntries);
            var sentences = new List<ProcessedSentence>();
            
            for (int i = 0; i < sentenceTexts.Length; i++)
            {
                var sentenceText = sentenceTexts[i].Trim();
                if (string.IsNullOrWhiteSpace(sentenceText)) continue;
                
                var wordTexts = sentenceText.Split(new[] { ' ', '„ÄÄ' }, StringSplitOptions.RemoveEmptyEntries);
                var words = new List<ProcessedWord>();
                
                for (int j = 0; j < wordTexts.Length; j++)
                {
                    words.Add(new ProcessedWord
                    {
                        Original = wordTexts[j],
                        Normalized = wordTexts[j].ToLower(),
                        Index = j,
                        PositionInSentence = j
                    });
                }
                
                sentences.Add(new ProcessedSentence
                {
                    Index = i,
                    OriginalText = sentenceText,
                    Words = words
                });
            }
            
            _processedText = new ProcessedText
            {
                OriginalText = _originalText,
                SourceLanguage = SourceLang,
                TargetLanguage = TargetLang,
                Sentences = sentences
            };
            
            // Show text immediately
            StateHasChanged();
            
            // STEP 3: Process text in background (translations, transliterations, etc.)
            _ = Task.Run(async () =>
            {
                try
                {
                    var processed = await Facade.ProcessTextAsync(_originalText, SourceLang, TargetLang);
                    _processedText = processed;
                    
                    Console.WriteLine($"‚úÖ Text processed: {_processedText.TotalSentences} sentences, {_processedText.TotalWords} words");
                    await InvokeAsync(StateHasChanged);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"‚ùå Background processing error: {ex.Message}");
                }
            });
        }
        catch (Exception ex)
        {
            _errorMessage = ex.Message;
            Console.WriteLine($"‚ùå Error loading text: {ex.Message}");
        }
    }
    
    private DifficultyLevel ParseDifficulty(string textId)
    {
        // Extract difficulty from textId if it contains it
        // Default to Beginner if not found
        if (textId.Contains("intermediate", StringComparison.OrdinalIgnoreCase))
            return DifficultyLevel.Intermediate;
        if (textId.Contains("advanced", StringComparison.OrdinalIgnoreCase))
            return DifficultyLevel.Advanced;
        
        return DifficultyLevel.Beginner;
    }
    
    private void GoBack()
    {
        Navigation.NavigateTo("/");
    }
    
    private string GetTextDirection(string lang)
    {
        return lang == "ar" ? "rtl" : "ltr";
    }

    [Inject] private IJSRuntime Js { get; set; } = default!;
    private DotNetObjectReference<ReadingPage>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (SourceLang == "ja")
        {
            try
            {
                // attempt to call client helper if present (backward compatible)
                await Js.InvokeVoidAsync("applyFuriganaToPending");

                // Create a DotNetObjectReference to receive batch updates
                if (_dotNetRef == null)
                {
                    _dotNetRef = DotNetObjectReference.Create(this);
                }

                // Call the new JS batch applier which will both patch DOM and notify Blazor
                await Js.InvokeVoidAsync("applyFuriganaToPendingAndNotify", _dotNetRef);

                // Debug: count transliterations assigned (after potential batch)
                try
                {
                    var count = _processedText?.Sentences.SelectMany(s => s.Words).Count(w => !string.IsNullOrEmpty(w.Transliteration)) ?? 0;
                    Console.WriteLine($"[Debug] Transliteration assigned count: {count}");
                }
                catch { }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Debug] OnAfterRender JS call failed: {ex.Message}");
            }
        }
    }

    [JSInvokable]
    public Task ReceiveFuriganaBatch(System.Text.Json.JsonElement updatesElement)
    {
        try
        {
            var updates = new List<FuriganaUpdate>();
            if (updatesElement.ValueKind == System.Text.Json.JsonValueKind.Array)
            {
                foreach (var item in updatesElement.EnumerateArray())
                {
                    try
                    {
                        var u = System.Text.Json.JsonSerializer.Deserialize<FuriganaUpdate>(item.GetRawText());
                        if (u != null) updates.Add(u);
                    }
                    catch { }
                }
            }

            foreach (var u in updates)
            {
                // Find matching word(s) in processed text by Original or Normalized
                foreach (var sentence in _processedText?.Sentences ?? Enumerable.Empty<ProcessedSentence>())
                {
                    foreach (var word in sentence.Words)
                    {
                        if (string.Equals(word.Original?.Trim(), u.Original?.Trim(), StringComparison.Ordinal))
                        {
                            if (!string.IsNullOrEmpty(u.Furigana)) word.Furigana = u.Furigana;
                            if (!string.IsNullOrEmpty(u.Romaji)) word.Transliteration = u.Romaji;
                        }
                    }
                }
            }

            // Trigger re-render
            InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[JSInvokable] ReceiveFuriganaBatch failed: {ex.Message}");
        }

        return Task.CompletedTask;
    }

    private class FuriganaUpdate { public string? Original { get; set; } public string? Furigana { get; set; } public string? Romaji { get; set; } }

    public void Dispose()
    {
        try
        {
            _dotNetRef?.Dispose();
            _dotNetRef = null;
        }
        catch { }
    }
}

@code {
    private string GetTooltip(ProcessedWord word) => !string.IsNullOrEmpty(word.Translation) ? word.Translation : word.Original;
}

@code {
    // Extract plain meanings from a translation string by stripping HTML and splitting on common separators.
    // Returns a list of short, trimmed meaning lines.
    private static List<string> ExtractMeanings(string translation)
    {
        if (string.IsNullOrWhiteSpace(translation)) return new List<string>();

        // Remove simple HTML tags and wiki link fragments. Keep inner text of anchors and italics.
        // This is a lightweight sanitizer ‚Äî not a full HTML parser.
        var text = System.Text.RegularExpressions.Regex.Replace(translation, "<\\s*br\\s*/?\\s*>", "\\n", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
        text = System.Text.RegularExpressions.Regex.Replace(text, "<\\s*(/?)(a|i|em|strong|span)[^>]*>", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase);

        // Remove any remaining tags
        text = System.Text.RegularExpressions.Regex.Replace(text, "<[^>]+>", "", System.Text.RegularExpressions.RegexOptions.Singleline);

        // Replace common separators used when joining meanings (semicolon, slash, pipe)
        text = text.Replace(";", "\n").Replace("/", "\n").Replace("|", "\n");

        // Split into lines and trim
        var lines = text.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(l => l.Trim())
            .Where(l => !string.IsNullOrEmpty(l))
            .ToList();

        // If there are parentheses-wrapped transliterations like (T≈çhoku), remove them from meanings
        for (int i = 0; i < lines.Count; i++)
        {
            lines[i] = System.Text.RegularExpressions.Regex.Replace(lines[i], "\\s*\\([^)]*\\)", "");
            lines[i] = lines[i].Trim();
        }

        // Optionally collapse duplicates
        var distinct = lines.Distinct().ToList();
        return distinct;
    }
}

<style>
    .reading-container {
        max-width: 900px;
        margin: 0 auto;
        padding: 2rem;
    }
    
    .reading-header {
        margin-bottom: 2rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #e0e0e0;
    }
    
    .btn-back {
        background: #6c757d;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        margin-bottom: 1rem;
        font-size: 1rem;
    }
    
    .btn-back:hover {
        background: #5a6268;
    }
    
    .text-info h1 {
        margin: 0.5rem 0;
        color: #2c3e50;
        font-size: 2rem;
    }
    
    .meta {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
        flex-wrap: wrap;
    }
    
    .badge {
        background: #3498db;
        color: white;
        padding: 0.25rem 0.75rem;
        border-radius: 4px;
        font-size: 0.875rem;
        font-weight: 500;
    }
    
    .difficulty-beginner {
        background: #27ae60;
    }
    
    .difficulty-intermediate {
        background: #f39c12;
    }
    
    .difficulty-advanced {
        background: #e74c3c;
    }
    
    .alert {
        padding: 1rem;
        border-radius: 4px;
        margin: 1rem 0;
    }
    
    .alert-danger {
        background: #fadbd8;
        border-left: 4px solid #e74c3c;
        color: #c0392b;
    }
    
    .btn-retry {
        margin-top: 0.5rem;
        background: #e74c3c;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
    }
    
    .btn-retry:hover {
        background: #c0392b;
    }
    
    .stats {
        background: #e8f5e9;
        padding: 1rem;
        border-radius: 4px;
        margin-bottom: 1.5rem;
        border-left: 4px solid #4caf50;
        font-size: 0.95rem;
    }
    
    .sentence {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
        padding: 1.5rem;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        transition: box-shadow 0.3s ease;
    }
    
    .sentence:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .sentence-number {
        font-weight: bold;
        color: #3498db;
        font-size: 1.2rem;
        min-width: 30px;
    }
    
    .sentence-content {
        flex: 1;
    }
    
    .sentence-text {
        font-size: 1.1rem;
        line-height: 2.2;
        display: inline;
        word-spacing: 0.3rem;
    }
    
    .word-wrapper {
        display: inline-block;
        position: relative;
        cursor: pointer;
        padding: 0.2rem 0.4rem;
        margin: 0.1rem;
        border-radius: 4px;
        transition: background-color 0.2s ease;
        vertical-align: middle;
    }
    
    .word-wrapper:hover {
        background-color: #fff3cd;
    }
    
    .word-original {
        display: inline-block;
        color: #2c3e50;
        font-weight: 500;
    }
    
    /* Word translation tooltip overlay to avoid layout jitter */
    .word-translation {
        display: block;
        position: absolute;
        left: 50%;
        transform: translateX(-50%) translateY(8px) scale(0.98);
        white-space: normal;
        max-width: 640px; /* allow wider tooltips for readable lists */
        min-width: 220px; /* avoid collapsing to a very thin column */
        font-size: 0.92rem;
        color: #142a2b;
        font-style: normal;
        padding: 10px 12px;
        background: linear-gradient(180deg, #ffffff, #fbfbfb);
        border: 1px solid rgba(16,24,32,0.06);
        border-radius: 8px;
        box-shadow: 0 12px 32px rgba(2,6,23,0.10);
        opacity: 0;
        visibility: hidden;
        transition: opacity 160ms cubic-bezier(.2,.9,.2,1), transform 160ms cubic-bezier(.2,.9,.2,1);
        z-index: 60;
        pointer-events: none;
        line-height: 1.45;
        text-align: left;
        word-break: break-word;
        overflow-wrap: anywhere;
        hyphens: auto;
        box-sizing: border-box;
    }

    /* Show overlay on hover or keyboard focus for accessibility */
    .word-wrapper:hover .word-translation,
    .word-wrapper:focus .word-translation,
    .word-wrapper:focus-within .word-translation {
        opacity: 1;
        visibility: visible;
        transform: translateX(-50%) translateY(12px) scale(1);
        pointer-events: auto;
    }

    /* Small arrow */
    .word-translation::after {
        content: "";
        position: absolute;
        top: -6px;
        left: 50%;
        transform: translateX(-50%) rotate(45deg);
        width: 12px;
        height: 12px;
        background: linear-gradient(180deg, #ffffff, #fbfbfb);
        border-left: 1px solid rgba(16,24,32,0.06);
        border-top: 1px solid rgba(16,24,32,0.06);
        box-shadow: -2px -2px 4px rgba(2,6,23,0.02);
        z-index: -1;
    }

    /* Transliteration line shown under word (reserve small gap) */
    .word-transliteration {
        font-size: 0.78rem;
        color: #7f8c8d;
        margin-top: 4px;
        text-align: center;
        line-height: 1.1;
        white-space: nowrap;
    }

    /* Reserve small space so tooltip doesn't overlap transliteration visually */
    .word-wrapper { padding-bottom: 0.6rem; }
    
    .punctuation {
        display: inline;
        color: #7f8c8d;
        margin: 0 0.1rem;
    }
    
    .sentence-translation {
        padding: 0.75rem;
        background: #f0f7ff;
        border-left: 3px solid #3498db;
        font-style: italic;
        color: #555;
        margin-top: 1rem;
        border-radius: 4px;
    }
    
    /* RTL support for Arabic */
    [dir="rtl"] {
        text-align: right;
    }
    
    [dir="rtl"] .sentence-text {
        direction: rtl;
    }

.sentence-actions {
    margin-bottom: 0.5rem;
}

.status-badge {
    display: inline-block;
    background: #e8f6ef;
    color: #117a65;
    border: 1px solid #b2dfdb;
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    margin-left: 0.5rem;
    font-size: 0.85rem;
}

.sentence-translate-btn {
    border: none;
    padding: 0 4px;
    margin-left: 8px;
    color: #5d6d7e;
    cursor: pointer;
}

.sentence-translate-btn:disabled {
    opacity: 0.6;
    cursor: default;
}

.status-icon {
    display:inline-block;
    width:10px;
    height:10px;
    border-radius:50%;
    margin-left:6px;
    vertical-align: middle;
}

/* Hide translate control by default, show on sentence hover */
.sentence-number .sentence-translate-btn { display: none; }
.sentence:hover .sentence-number .sentence-translate-btn { display: inline-block; }

.icon-translate { opacity: 0.9; }

.status-ok { background:#2ecc71; }
.status-fail { background:#e74c3c; }
.status-empty { background:#f1c40f; }

    /* Tooltip meanings list */
    .tooltip-meanings {
        margin: 0;
        padding: 0.15rem 0 0 1.1rem;
        list-style: disc;
        font-size: 0.95rem;
        color: #163c3b;
        display: block;
        max-width: 100%;
    }
    .tooltip-meanings li {
        margin: 0.15rem 0;
        line-height: 1.3;
        word-break: break-word;
        overflow-wrap: anywhere;
    }
</style>